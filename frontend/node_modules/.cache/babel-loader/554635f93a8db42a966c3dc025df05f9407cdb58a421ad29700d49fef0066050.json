{"ast":null,"code":"// frontend/src/utils/ShapeDetector.js\n// Full ShapeDetector class: grayscale -> binary -> connected components -> contour tracing\n// -> Douglas-Peucker approx -> convex hull & colinear cleanup -> robust classification\n// Exports: default class ShapeDetector with async detectShapes(imageData) method.\n\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n    this.minArea = 50; // ignore tiny blobs\n  }\n  async detectShapes(imageData) {\n    const t0 = performance.now();\n    const {\n      width,\n      height,\n      data\n    } = imageData;\n\n    // 1) convert to grayscale + binary mask (0/1)\n    const mask = new Uint8Array(width * height);\n    for (let i = 0, p = 0; i < data.length; i += 4, p++) {\n      const r = data[i],\n        g = data[i + 1],\n        b = data[i + 2];\n      const l = 0.299 * r + 0.587 * g + 0.114 * b | 0;\n      mask[p] = l < this.threshold ? 1 : 0; // foreground=1 for dark shapes\n    }\n\n    // 2) connected components (4-neighbor flood fill)\n    const seen = new Uint8Array(width * height);\n    const shapes = [];\n    const stack = [];\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const idx = y * width + x;\n        if (mask[idx] === 1 && !seen[idx]) {\n          // flood fill\n          let area = 0;\n          let minX = x,\n            minY = y,\n            maxX = x,\n            maxY = y;\n          stack.push(idx);\n          seen[idx] = 1;\n          const pixels = [];\n          while (stack.length) {\n            const cur = stack.pop();\n            const cx = cur % width;\n            const cy = cur / width | 0;\n            pixels.push({\n              x: cx,\n              y: cy\n            });\n            area++;\n            if (cx < minX) minX = cx;\n            if (cy < minY) minY = cy;\n            if (cx > maxX) maxX = cx;\n            if (cy > maxY) maxY = cy;\n\n            // neighbors 4-connectivity\n            const n1 = cur - 1,\n              n2 = cur + 1,\n              n3 = cur - width,\n              n4 = cur + width;\n            if (cx > 0) {\n              if (!seen[n1] && mask[n1] === 1) {\n                seen[n1] = 1;\n                stack.push(n1);\n              }\n            }\n            if (cx < width - 1) {\n              if (!seen[n2] && mask[n2] === 1) {\n                seen[n2] = 1;\n                stack.push(n2);\n              }\n            }\n            if (cy > 0) {\n              if (!seen[n3] && mask[n3] === 1) {\n                seen[n3] = 1;\n                stack.push(n3);\n              }\n            }\n            if (cy < height - 1) {\n              if (!seen[n4] && mask[n4] === 1) {\n                seen[n4] = 1;\n                stack.push(n4);\n              }\n            }\n          } // end flood\n\n          if (area >= this.minArea) {\n            // trace contour (boundary pixels)\n            const contour = this._traceBoundary(mask, width, height, minX, minY, maxX, maxY);\n            shapes.push({\n              pixels,\n              contour,\n              area,\n              boundingBox: {\n                x: minX,\n                y: minY,\n                width: maxX - minX + 1,\n                height: maxY - minY + 1\n              }\n            });\n          }\n        }\n      }\n    }\n\n    // 3) analyze each shape: approx -> hull -> classify -> compute center & confidence\n    const outShapes = [];\n    for (const s of shapes) {\n      if (!s.contour || s.contour.length < 6) {\n        // tiny or degenerate, skip\n        continue;\n      }\n      const perimeter = polygonPerimeter(s.contour);\n      const eps = Math.max(4, 0.02 * perimeter);\n      const approx = douglasPeucker(s.contour, eps);\n      const approxClean = removeColinear(approx, 6);\n      const hull = convexHull(approxClean);\n      const hullClean = removeColinear(hull, 6);\n      const area = s.area;\n      const circularity = perimeter > 0 ? 4 * Math.PI * area / (perimeter * perimeter) : 0;\n      let type = 'polygon';\n      if (hullClean.length === 3) {\n        type = 'triangle';\n      } else if (hullClean.length === 4) {\n        // aspect ratio test\n        let minX = Infinity,\n          minY = Infinity,\n          maxX = -Infinity,\n          maxY = -Infinity;\n        hullClean.forEach(p => {\n          if (p.x < minX) minX = p.x;\n          if (p.y < minY) minY = p.y;\n          if (p.x > maxX) maxX = p.x;\n          if (p.y > maxY) maxY = p.y;\n        });\n        const w = maxX - minX || 1;\n        const h = maxY - minY || 1;\n        const ar = w / h;\n        type = Math.abs(ar - 1) < 0.12 ? 'square' : 'rectangle';\n      } else if (circularity > 0.7) {\n        type = 'circle';\n      } else {\n        type = 'polygon';\n      }\n      const center = centroidFromPixels(s.pixels);\n      const bbox = s.boundingBox;\n      const confidence = computeConfidence(type, hullClean.length, circularity, area, perimeter);\n      outShapes.push({\n        type,\n        vertices: hullClean,\n        rawVertices: approx,\n        center,\n        area,\n        boundingBox: bbox,\n        confidence\n      });\n    } // end for shapes\n\n    const t1 = performance.now();\n    return {\n      shapes: outShapes,\n      processingTime: t1 - t0\n    };\n  } // end detectShapes\n\n  // ----- helper methods below -----\n\n  // trace boundary using simple neighbor search inside bounding box\n  _traceBoundary(mask, width, height, minX, minY, maxX, maxY) {\n    const boundary = [];\n    // iterate bounding box and collect pixels that have at least one 4-neighbor background\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        const idx = y * width + x;\n        if (mask[idx] !== 1) continue;\n        const left = x > 0 ? mask[idx - 1] : 0;\n        const right = x < width - 1 ? mask[idx + 1] : 0;\n        const up = y > 0 ? mask[idx - width] : 0;\n        const down = y < height - 1 ? mask[idx + width] : 0;\n        if (left === 0 || right === 0 || up === 0 || down === 0) {\n          boundary.push({\n            x,\n            y\n          });\n        }\n      }\n    }\n    // order boundary points to form a path (nearest-neighbor greedy)\n    return orderBoundary(boundary);\n  }\n}\n\n// ---------- Utility functions (inside file) ----------\n\nfunction orderBoundary(points) {\n  if (!points || points.length === 0) return [];\n  const used = new Array(points.length).fill(false);\n  const out = [];\n  let idx = 0;\n  out.push(points[idx]);\n  used[idx] = true;\n  for (let step = 1; step < points.length; step++) {\n    let best = -1;\n    let bestDist = Infinity;\n    const cur = out[out.length - 1];\n    for (let i = 0; i < points.length; i++) {\n      if (used[i]) continue;\n      const dx = points[i].x - cur.x;\n      const dy = points[i].y - cur.y;\n      const d = dx * dx + dy * dy;\n      if (d < bestDist) {\n        bestDist = d;\n        best = i;\n      }\n    }\n    if (best === -1) break;\n    used[best] = true;\n    out.push(points[best]);\n  }\n  return out;\n}\nfunction polygonPerimeter(points) {\n  let p = 0;\n  for (let i = 0; i < points.length; i++) {\n    const a = points[i];\n    const b = points[(i + 1) % points.length];\n    const dx = a.x - b.x,\n      dy = a.y - b.y;\n    p += Math.hypot(dx, dy);\n  }\n  return p;\n}\n\n// centroid by pixels\nfunction centroidFromPixels(pixels) {\n  if (!pixels || pixels.length === 0) return {\n    x: 0,\n    y: 0\n  };\n  let sx = 0,\n    sy = 0;\n  for (let i = 0; i < pixels.length; i++) {\n    sx += pixels[i].x;\n    sy += pixels[i].y;\n  }\n  return {\n    x: Math.round(sx / pixels.length),\n    y: Math.round(sy / pixels.length)\n  };\n}\nfunction computeConfidence(type, vCount, circularity, area, perimeter) {\n  let base = 0.5;\n  if (type === 'triangle') base = 0.9;\n  if (type === 'square' || type === 'rectangle') base = 0.88;\n  if (type === 'circle') base = 0.93;\n  if (type === 'polygon') base = 0.65;\n  // bump by circularity and polygon compactness\n  const circBoost = Math.min(0.15, Math.max(0, (circularity - 0.4) * 0.5));\n  const sizeBoost = Math.min(0.2, Math.log10(Math.max(10, area)) * 0.03);\n  return Math.max(0.12, Math.min(0.99, base + circBoost + sizeBoost));\n}\n\n// --- Douglas-Peucker (recursive) ---\n// input: points = [{x,y}, ...], epsilon in pixels\nfunction douglasPeucker(points, epsilon) {\n  if (!points || points.length < 3) return points.slice();\n  const first = 0,\n    last = points.length - 1;\n  const stack = [[first, last]];\n  const keep = new Array(points.length).fill(false);\n  keep[first] = true;\n  keep[last] = true;\n  function perpendicularDistance(pt, a, b) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    if (dx === 0 && dy === 0) {\n      return Math.hypot(pt.x - a.x, pt.y - a.y);\n    }\n    const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);\n    const projx = a.x + t * dx;\n    const projy = a.y + t * dy;\n    return Math.hypot(pt.x - projx, pt.y - projy);\n  }\n  while (stack.length > 0) {\n    const [i, j] = stack.pop();\n    let maxDist = 0;\n    let index = -1;\n    for (let k = i + 1; k < j; k++) {\n      const d = perpendicularDistance(points[k], points[i], points[j]);\n      if (d > maxDist) {\n        maxDist = d;\n        index = k;\n      }\n    }\n    if (maxDist > epsilon) {\n      keep[index] = true;\n      stack.push([i, index]);\n      stack.push([index, j]);\n    }\n  }\n  const res = [];\n  for (let i = 0; i < points.length; i++) if (keep[i]) res.push(points[i]);\n  return res;\n}\n\n// --- convex hull (Monotone chain) ---\nfunction cross(o, a, b) {\n  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\nfunction convexHull(points) {\n  if (!points || points.length <= 1) return points.slice();\n  const pts = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);\n  const lower = [];\n  for (const p of pts) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();\n    lower.push(p);\n  }\n  const upper = [];\n  for (let i = pts.length - 1; i >= 0; i--) {\n    const p = pts[i];\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();\n    upper.push(p);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\n// remove near-colinear consecutive points (closed polygon)\nfunction removeColinear(points, angleTolDeg = 6) {\n  if (!points || points.length <= 3) return points.slice();\n  const res = [];\n  const tol = angleTolDeg * Math.PI / 180;\n  for (let i = 0; i < points.length; i++) {\n    const prev = points[(i - 1 + points.length) % points.length];\n    const cur = points[i];\n    const next = points[(i + 1) % points.length];\n    const v1x = prev.x - cur.x,\n      v1y = prev.y - cur.y;\n    const v2x = next.x - cur.x,\n      v2y = next.y - cur.y;\n    const n1 = Math.hypot(v1x, v1y) || 1;\n    const n2 = Math.hypot(v2x, v2y) || 1;\n    const dot = (v1x * v2x + v1y * v2y) / (n1 * n2);\n    // clamp\n    const ang = Math.acos(Math.max(-1, Math.min(1, dot)));\n    if (Math.abs(Math.PI - ang) > tol) {\n      res.push(cur);\n    }\n  }\n  return res.length >= 3 ? res : points.slice();\n}\nexport default ShapeDetector;","map":{"version":3,"names":["ShapeDetector","constructor","threshold","minArea","detectShapes","imageData","t0","performance","now","width","height","data","mask","Uint8Array","i","p","length","r","g","b","l","seen","shapes","stack","y","x","idx","area","minX","minY","maxX","maxY","push","pixels","cur","pop","cx","cy","n1","n2","n3","n4","contour","_traceBoundary","boundingBox","outShapes","s","perimeter","polygonPerimeter","eps","Math","max","approx","douglasPeucker","approxClean","removeColinear","hull","convexHull","hullClean","circularity","PI","type","Infinity","forEach","w","h","ar","abs","center","centroidFromPixels","bbox","confidence","computeConfidence","vertices","rawVertices","t1","processingTime","boundary","left","right","up","down","orderBoundary","points","used","Array","fill","out","step","best","bestDist","dx","dy","d","a","hypot","sx","sy","round","vCount","base","circBoost","min","sizeBoost","log10","epsilon","slice","first","last","keep","perpendicularDistance","pt","t","projx","projy","j","maxDist","index","k","res","cross","o","pts","sort","lower","upper","concat","angleTolDeg","tol","prev","next","v1x","v1y","v2x","v2y","dot","ang","acos"],"sources":["C:/Users/yadla/Downloads/shape-detection/frontend/src/utils/ShapeDetector.js"],"sourcesContent":["// frontend/src/utils/ShapeDetector.js\n// Full ShapeDetector class: grayscale -> binary -> connected components -> contour tracing\n// -> Douglas-Peucker approx -> convex hull & colinear cleanup -> robust classification\n// Exports: default class ShapeDetector with async detectShapes(imageData) method.\n\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n    this.minArea = 50; // ignore tiny blobs\n  }\n\n  async detectShapes(imageData) {\n    const t0 = performance.now();\n    const { width, height, data } = imageData;\n\n    // 1) convert to grayscale + binary mask (0/1)\n    const mask = new Uint8Array(width * height);\n    for (let i = 0, p = 0; i < data.length; i += 4, p++) {\n      const r = data[i], g = data[i + 1], b = data[i + 2];\n      const l = (0.299 * r + 0.587 * g + 0.114 * b) | 0;\n      mask[p] = l < this.threshold ? 1 : 0; // foreground=1 for dark shapes\n    }\n\n    // 2) connected components (4-neighbor flood fill)\n    const seen = new Uint8Array(width * height);\n    const shapes = [];\n    const stack = [];\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const idx = y * width + x;\n        if (mask[idx] === 1 && !seen[idx]) {\n          // flood fill\n          let area = 0;\n          let minX = x, minY = y, maxX = x, maxY = y;\n          stack.push(idx);\n          seen[idx] = 1;\n          const pixels = [];\n          while (stack.length) {\n            const cur = stack.pop();\n            const cx = cur % width;\n            const cy = (cur / width) | 0;\n            pixels.push({ x: cx, y: cy });\n            area++;\n            if (cx < minX) minX = cx;\n            if (cy < minY) minY = cy;\n            if (cx > maxX) maxX = cx;\n            if (cy > maxY) maxY = cy;\n\n            // neighbors 4-connectivity\n            const n1 = cur - 1, n2 = cur + 1, n3 = cur - width, n4 = cur + width;\n            if (cx > 0) {\n              if (!seen[n1] && mask[n1] === 1) { seen[n1] = 1; stack.push(n1); }\n            }\n            if (cx < width - 1) {\n              if (!seen[n2] && mask[n2] === 1) { seen[n2] = 1; stack.push(n2); }\n            }\n            if (cy > 0) {\n              if (!seen[n3] && mask[n3] === 1) { seen[n3] = 1; stack.push(n3); }\n            }\n            if (cy < height - 1) {\n              if (!seen[n4] && mask[n4] === 1) { seen[n4] = 1; stack.push(n4); }\n            }\n          } // end flood\n\n          if (area >= this.minArea) {\n            // trace contour (boundary pixels)\n            const contour = this._traceBoundary(mask, width, height, minX, minY, maxX, maxY);\n            shapes.push({\n              pixels,\n              contour,\n              area,\n              boundingBox: { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 },\n            });\n          }\n        }\n      }\n    }\n\n    // 3) analyze each shape: approx -> hull -> classify -> compute center & confidence\n    const outShapes = [];\n    for (const s of shapes) {\n      if (!s.contour || s.contour.length < 6) {\n        // tiny or degenerate, skip\n        continue;\n      }\n\n      const perimeter = polygonPerimeter(s.contour);\n      const eps = Math.max(4, 0.02 * perimeter);\n\n      const approx = douglasPeucker(s.contour, eps);\n      const approxClean = removeColinear(approx, 6);\n      const hull = convexHull(approxClean);\n      const hullClean = removeColinear(hull, 6);\n\n      const area = s.area;\n      const circularity = perimeter > 0 ? (4 * Math.PI * area) / (perimeter * perimeter) : 0;\n\n      let type = 'polygon';\n      if (hullClean.length === 3) {\n        type = 'triangle';\n      } else if (hullClean.length === 4) {\n        // aspect ratio test\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n        hullClean.forEach(p => {\n          if (p.x < minX) minX = p.x;\n          if (p.y < minY) minY = p.y;\n          if (p.x > maxX) maxX = p.x;\n          if (p.y > maxY) maxY = p.y;\n        });\n        const w = maxX - minX || 1;\n        const h = maxY - minY || 1;\n        const ar = w / h;\n        type = Math.abs(ar - 1) < 0.12 ? 'square' : 'rectangle';\n      } else if (circularity > 0.7) {\n        type = 'circle';\n      } else {\n        type = 'polygon';\n      }\n\n      const center = centroidFromPixels(s.pixels);\n      const bbox = s.boundingBox;\n      const confidence = computeConfidence(type, hullClean.length, circularity, area, perimeter);\n\n      outShapes.push({\n        type,\n        vertices: hullClean,\n        rawVertices: approx,\n        center,\n        area,\n        boundingBox: bbox,\n        confidence,\n      });\n    } // end for shapes\n\n    const t1 = performance.now();\n    return {\n      shapes: outShapes,\n      processingTime: t1 - t0,\n    };\n  } // end detectShapes\n\n\n  // ----- helper methods below -----\n\n  // trace boundary using simple neighbor search inside bounding box\n  _traceBoundary(mask, width, height, minX, minY, maxX, maxY) {\n    const boundary = [];\n    // iterate bounding box and collect pixels that have at least one 4-neighbor background\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        const idx = y * width + x;\n        if (mask[idx] !== 1) continue;\n        const left = x > 0 ? mask[idx - 1] : 0;\n        const right = x < width - 1 ? mask[idx + 1] : 0;\n        const up = y > 0 ? mask[idx - width] : 0;\n        const down = y < height - 1 ? mask[idx + width] : 0;\n        if (left === 0 || right === 0 || up === 0 || down === 0) {\n          boundary.push({ x, y });\n        }\n      }\n    }\n    // order boundary points to form a path (nearest-neighbor greedy)\n    return orderBoundary(boundary);\n  }\n}\n\n\n// ---------- Utility functions (inside file) ----------\n\nfunction orderBoundary(points) {\n  if (!points || points.length === 0) return [];\n  const used = new Array(points.length).fill(false);\n  const out = [];\n  let idx = 0;\n  out.push(points[idx]);\n  used[idx] = true;\n  for (let step = 1; step < points.length; step++) {\n    let best = -1;\n    let bestDist = Infinity;\n    const cur = out[out.length - 1];\n    for (let i = 0; i < points.length; i++) {\n      if (used[i]) continue;\n      const dx = points[i].x - cur.x;\n      const dy = points[i].y - cur.y;\n      const d = dx * dx + dy * dy;\n      if (d < bestDist) {\n        bestDist = d;\n        best = i;\n      }\n    }\n    if (best === -1) break;\n    used[best] = true;\n    out.push(points[best]);\n  }\n  return out;\n}\n\nfunction polygonPerimeter(points) {\n  let p = 0;\n  for (let i = 0; i < points.length; i++) {\n    const a = points[i];\n    const b = points[(i + 1) % points.length];\n    const dx = a.x - b.x, dy = a.y - b.y;\n    p += Math.hypot(dx, dy);\n  }\n  return p;\n}\n\n// centroid by pixels\nfunction centroidFromPixels(pixels) {\n  if (!pixels || pixels.length === 0) return { x: 0, y: 0 };\n  let sx = 0, sy = 0;\n  for (let i = 0; i < pixels.length; i++) {\n    sx += pixels[i].x;\n    sy += pixels[i].y;\n  }\n  return { x: Math.round(sx / pixels.length), y: Math.round(sy / pixels.length) };\n}\n\nfunction computeConfidence(type, vCount, circularity, area, perimeter) {\n  let base = 0.5;\n  if (type === 'triangle') base = 0.9;\n  if (type === 'square' || type === 'rectangle') base = 0.88;\n  if (type === 'circle') base = 0.93;\n  if (type === 'polygon') base = 0.65;\n  // bump by circularity and polygon compactness\n  const circBoost = Math.min(0.15, Math.max(0, (circularity - 0.4) * 0.5));\n  const sizeBoost = Math.min(0.2, Math.log10(Math.max(10, area)) * 0.03);\n  return Math.max(0.12, Math.min(0.99, base + circBoost + sizeBoost));\n}\n\n// --- Douglas-Peucker (recursive) ---\n// input: points = [{x,y}, ...], epsilon in pixels\nfunction douglasPeucker(points, epsilon) {\n  if (!points || points.length < 3) return points.slice();\n  const first = 0, last = points.length - 1;\n  const stack = [[first, last]];\n  const keep = new Array(points.length).fill(false);\n  keep[first] = true;\n  keep[last] = true;\n\n  function perpendicularDistance(pt, a, b) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    if (dx === 0 && dy === 0) {\n      return Math.hypot(pt.x - a.x, pt.y - a.y);\n    }\n    const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);\n    const projx = a.x + t * dx;\n    const projy = a.y + t * dy;\n    return Math.hypot(pt.x - projx, pt.y - projy);\n  }\n\n  while (stack.length > 0) {\n    const [i, j] = stack.pop();\n    let maxDist = 0;\n    let index = -1;\n    for (let k = i + 1; k < j; k++) {\n      const d = perpendicularDistance(points[k], points[i], points[j]);\n      if (d > maxDist) { maxDist = d; index = k; }\n    }\n    if (maxDist > epsilon) {\n      keep[index] = true;\n      stack.push([i, index]);\n      stack.push([index, j]);\n    }\n  }\n\n  const res = [];\n  for (let i = 0; i < points.length; i++) if (keep[i]) res.push(points[i]);\n  return res;\n}\n\n// --- convex hull (Monotone chain) ---\nfunction cross(o, a, b) {\n  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\nfunction convexHull(points) {\n  if (!points || points.length <= 1) return points.slice();\n  const pts = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);\n  const lower = [];\n  for (const p of pts) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();\n    lower.push(p);\n  }\n  const upper = [];\n  for (let i = pts.length - 1; i >= 0; i--) {\n    const p = pts[i];\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();\n    upper.push(p);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\n// remove near-colinear consecutive points (closed polygon)\nfunction removeColinear(points, angleTolDeg = 6) {\n  if (!points || points.length <= 3) return points.slice();\n  const res = [];\n  const tol = (angleTolDeg * Math.PI) / 180;\n  for (let i = 0; i < points.length; i++) {\n    const prev = points[(i - 1 + points.length) % points.length];\n    const cur = points[i];\n    const next = points[(i + 1) % points.length];\n\n    const v1x = prev.x - cur.x, v1y = prev.y - cur.y;\n    const v2x = next.x - cur.x, v2y = next.y - cur.y;\n    const n1 = Math.hypot(v1x, v1y) || 1;\n    const n2 = Math.hypot(v2x, v2y) || 1;\n    const dot = (v1x * v2x + v1y * v2y) / (n1 * n2);\n    // clamp\n    const ang = Math.acos(Math.max(-1, Math.min(1, dot)));\n    if (Math.abs(Math.PI - ang) > tol) {\n      res.push(cur);\n    }\n  }\n  return res.length >= 3 ? res : points.slice();\n}\n\nexport default ShapeDetector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}