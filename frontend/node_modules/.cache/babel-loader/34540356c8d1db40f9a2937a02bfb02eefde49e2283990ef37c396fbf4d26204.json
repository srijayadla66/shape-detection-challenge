{"ast":null,"code":"// frontend/src/utils/ShapeDetector.js\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n    this.minArea = 30;\n  }\n  async detectShapes(imageData) {\n    const t0 = performance.now();\n    const {\n      width,\n      height,\n      data\n    } = imageData;\n\n    // grayscale -> binary mask\n    let mask = new Uint8Array(width * height);\n    for (let i = 0, p = 0; i < data.length; i += 4, p++) {\n      const r = data[i],\n        g = data[i + 1],\n        b = data[i + 2];\n      const l = 0.299 * r + 0.587 * g + 0.114 * b | 0;\n      mask[p] = l < this.threshold ? 1 : 0;\n    }\n\n    // morphology: close gaps and fill holes\n    mask = morphologicalClose(mask, width, height, 5);\n    mask = fillHoles(mask, width, height);\n\n    // connected components (4-neighbor)\n    const seen = new Uint8Array(width * height);\n    let shapes = [];\n    const stack = [];\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const idx = y * width + x;\n        if (mask[idx] === 1 && !seen[idx]) {\n          let area = 0;\n          let minX = x,\n            minY = y,\n            maxX = x,\n            maxY = y;\n          stack.push(idx);\n          seen[idx] = 1;\n          const pixels = [];\n          while (stack.length) {\n            const cur = stack.pop();\n            const cx = cur % width;\n            const cy = cur / width | 0;\n            pixels.push({\n              x: cx,\n              y: cy\n            });\n            area++;\n            if (cx < minX) minX = cx;\n            if (cy < minY) minY = cy;\n            if (cx > maxX) maxX = cx;\n            if (cy > maxY) maxY = cy;\n            const n1 = cur - 1,\n              n2 = cur + 1,\n              n3 = cur - width,\n              n4 = cur + width;\n            if (cx > 0) {\n              if (!seen[n1] && mask[n1] === 1) {\n                seen[n1] = 1;\n                stack.push(n1);\n              }\n            }\n            if (cx < width - 1) {\n              if (!seen[n2] && mask[n2] === 1) {\n                seen[n2] = 1;\n                stack.push(n2);\n              }\n            }\n            if (cy > 0) {\n              if (!seen[n3] && mask[n3] === 1) {\n                seen[n3] = 1;\n                stack.push(n3);\n              }\n            }\n            if (cy < height - 1) {\n              if (!seen[n4] && mask[n4] === 1) {\n                seen[n4] = 1;\n                stack.push(n4);\n              }\n            }\n          }\n          if (area >= this.minArea) {\n            const contour = this._traceBoundary(mask, width, height, minX, minY, maxX, maxY);\n            shapes.push({\n              pixels,\n              contour,\n              area,\n              boundingBox: {\n                x: minX,\n                y: minY,\n                width: maxX - minX + 1,\n                height: maxY - minY + 1\n              }\n            });\n          }\n        }\n      }\n    }\n\n    // merge nearby boxes\n    shapes = mergeCloseBoxes(shapes, 8);\n    const outShapes = [];\n    for (const s of shapes) {\n      if (!s.contour || s.contour.length < 6 || s.area && s.contour.length < Math.max(6, Math.sqrt(s.area) * 0.15)) {\n        const b = s.boundingBox;\n        s.contour = [{\n          x: b.x,\n          y: b.y\n        }, {\n          x: b.x + b.width,\n          y: b.y\n        }, {\n          x: b.x + b.width,\n          y: b.y + b.height\n        }, {\n          x: b.x,\n          y: b.y + b.height\n        }];\n      }\n      const perimeter = polygonPerimeter(s.contour);\n      const eps = Math.max(3, 0.03 * perimeter);\n      const approx = douglasPeucker(s.contour, eps);\n      const approxClean = removeColinear(approx, 8);\n      const hull = convexHull(approxClean);\n      const hullClean = removeColinear(hull, 8);\n      const area = s.area;\n      const circularity = perimeter > 0 ? 4 * Math.PI * area / (perimeter * perimeter) : 0;\n      let type = 'polygon';\n      if (hullClean.length === 3) {\n        type = 'triangle';\n      } else if (hullClean.length === 4) {\n        let minX = Infinity,\n          minY = Infinity,\n          maxX = -Infinity,\n          maxY = -Infinity;\n        hullClean.forEach(p => {\n          if (p.x < minX) minX = p.x;\n          if (p.y < minY) minY = p.y;\n          if (p.x > maxX) maxX = p.x;\n          if (p.y > maxY) maxY = p.y;\n        });\n        const w = maxX - minX || 1;\n        const h = maxY - minY || 1;\n        const ar = w / h;\n        type = Math.abs(ar - 1) < 0.12 ? 'square' : 'rectangle';\n      } else if (circularity > 0.7) {\n        type = 'circle';\n      } else {\n        type = 'polygon';\n      }\n      const center = centroidFromPixels(s.pixels);\n      const bbox = s.boundingBox;\n      const confidence = computeConfidence(type, hullClean.length, circularity, area, perimeter);\n      outShapes.push({\n        type,\n        vertices: hullClean,\n        rawVertices: approx,\n        center,\n        area,\n        boundingBox: bbox,\n        confidence\n      });\n    }\n    const t1 = performance.now();\n    return {\n      shapes: outShapes,\n      processingTime: t1 - t0\n    };\n  }\n  _traceBoundary(mask, width, height, minX, minY, maxX, maxY) {\n    const boundary = [];\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        const idx = y * width + x;\n        if (mask[idx] !== 1) continue;\n        const left = x > 0 ? mask[idx - 1] : 0;\n        const right = x < width - 1 ? mask[idx + 1] : 0;\n        const up = y > 0 ? mask[idx - width] : 0;\n        const down = y < height - 1 ? mask[idx + width] : 0;\n        if (left === 0 || right === 0 || up === 0 || down === 0) {\n          boundary.push({\n            x,\n            y\n          });\n        }\n      }\n    }\n    return orderBoundary(boundary);\n  }\n}\n\n// utility helpers\n\nfunction orderBoundary(points) {\n  if (!points || points.length === 0) return [];\n  const used = new Array(points.length).fill(false);\n  const out = [];\n  let idx = 0;\n  out.push(points[idx]);\n  used[idx] = true;\n  for (let step = 1; step < points.length; step++) {\n    let best = -1;\n    let bestDist = Infinity;\n    const cur = out[out.length - 1];\n    for (let i = 0; i < points.length; i++) {\n      if (used[i]) continue;\n      const dx = points[i].x - cur.x;\n      const dy = points[i].y - cur.y;\n      const d = dx * dx + dy * dy;\n      if (d < bestDist) {\n        bestDist = d;\n        best = i;\n      }\n    }\n    if (best === -1) break;\n    used[best] = true;\n    out.push(points[best]);\n  }\n  return out;\n}\nfunction polygonPerimeter(points) {\n  let p = 0;\n  for (let i = 0; i < points.length; i++) {\n    const a = points[i];\n    const b = points[(i + 1) % points.length];\n    const dx = a.x - b.x,\n      dy = a.y - b.y;\n    p += Math.hypot(dx, dy);\n  }\n  return p;\n}\nfunction centroidFromPixels(pixels) {\n  if (!pixels || pixels.length === 0) return {\n    x: 0,\n    y: 0\n  };\n  let sx = 0,\n    sy = 0;\n  for (let i = 0; i < pixels.length; i++) {\n    sx += pixels[i].x;\n    sy += pixels[i].y;\n  }\n  return {\n    x: Math.round(sx / pixels.length),\n    y: Math.round(sy / pixels.length)\n  };\n}\nfunction computeConfidence(type, vCount, circularity, area, perimeter) {\n  let base = 0.5;\n  if (type === 'triangle') base = 0.9;\n  if (type === 'square' || type === 'rectangle') base = 0.88;\n  if (type === 'circle') base = 0.93;\n  if (type === 'polygon') base = 0.65;\n  const circBoost = Math.min(0.15, Math.max(0, (circularity - 0.4) * 0.5));\n  const sizeBoost = Math.min(0.2, Math.log10(Math.max(10, area)) * 0.03);\n  return Math.max(0.12, Math.min(0.99, base + circBoost + sizeBoost));\n}\n\n// Douglas-Peucker\nfunction douglasPeucker(points, epsilon) {\n  if (!points || points.length < 3) return points.slice();\n  const first = 0,\n    last = points.length - 1;\n  const stack = [[first, last]];\n  const keep = new Array(points.length).fill(false);\n  keep[first] = true;\n  keep[last] = true;\n  function perpendicularDistance(pt, a, b) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    if (dx === 0 && dy === 0) {\n      return Math.hypot(pt.x - a.x, pt.y - a.y);\n    }\n    const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);\n    const projx = a.x + t * dx;\n    const projy = a.y + t * dy;\n    return Math.hypot(pt.x - projx, pt.y - projy);\n  }\n  while (stack.length > 0) {\n    const [i, j] = stack.pop();\n    let maxDist = 0;\n    let index = -1;\n    for (let k = i + 1; k < j; k++) {\n      const d = perpendicularDistance(points[k], points[i], points[j]);\n      if (d > maxDist) {\n        maxDist = d;\n        index = k;\n      }\n    }\n    if (maxDist > epsilon) {\n      keep[index] = true;\n      stack.push([i, index]);\n      stack.push([index, j]);\n    }\n  }\n  const res = [];\n  for (let i = 0; i < points.length; i++) if (keep[i]) res.push(points[i]);\n  return res;\n}\n\n// convex hull\nfunction cross(o, a, b) {\n  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\nfunction convexHull(points) {\n  if (!points || points.length <= 1) return points.slice();\n  const pts = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);\n  const lower = [];\n  for (const p of pts) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();\n    lower.push(p);\n  }\n  const upper = [];\n  for (let i = pts.length - 1; i >= 0; i--) {\n    const p = pts[i];\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();\n    upper.push(p);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\n// remove near-colinear consecutive points\nfunction removeColinear(points, angleTolDeg = 6) {\n  if (!points || points.length <= 3) return points.slice();\n  const res = [];\n  const tol = angleTolDeg * Math.PI / 180;\n  for (let i = 0; i < points.length; i++) {\n    const prev = points[(i - 1 + points.length) % points.length];\n    const cur = points[i];\n    const next = points[(i + 1) % points.length];\n    const v1x = prev.x - cur.x,\n      v1y = prev.y - cur.y;\n    const v2x = next.x - cur.x,\n      v2y = next.y - cur.y;\n    const n1 = Math.hypot(v1x, v1y) || 1;\n    const n2 = Math.hypot(v2x, v2y) || 1;\n    const dot = (v1x * v2x + v1y * v2y) / (n1 * n2);\n    const ang = Math.acos(Math.max(-1, Math.min(1, dot)));\n    if (Math.abs(Math.PI - ang) > tol) {\n      res.push(cur);\n    }\n  }\n  return res.length >= 3 ? res : points.slice();\n}\n\n// --- Morphology: closing ---\nfunction morphologicalClose(mask, width, height, k = 3) {\n  const out = new Uint8Array(mask.length);\n  const pad = Math.floor(k / 2);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let any = 0;\n      for (let ky = -pad; ky <= pad; ky++) {\n        const yy = y + ky;\n        if (yy < 0 || yy >= height) continue;\n        for (let kx = -pad; kx <= pad; kx++) {\n          const xx = x + kx;\n          if (xx < 0 || xx >= width) continue;\n          if (mask[yy * width + xx]) {\n            any = 1;\n            break;\n          }\n        }\n        if (any) break;\n      }\n      out[y * width + x] = any;\n    }\n  }\n  const out2 = new Uint8Array(mask.length);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let all = 1;\n      for (let ky = -pad; ky <= pad; ky++) {\n        const yy = y + ky;\n        if (yy < 0 || yy >= height) {\n          all = 0;\n          break;\n        }\n        for (let kx = -pad; kx <= pad; kx++) {\n          const xx = x + kx;\n          if (xx < 0 || xx >= width) {\n            all = 0;\n            break;\n          }\n          if (!out[yy * width + xx]) {\n            all = 0;\n            break;\n          }\n        }\n        if (!all) break;\n      }\n      out2[y * width + x] = all ? 1 : 0;\n    }\n  }\n  return out2;\n}\n\n// --- Fill holes ---\nfunction fillHoles(mask, width, height) {\n  const inv = new Uint8Array(mask.length);\n  for (let i = 0; i < mask.length; i++) inv[i] = mask[i] ? 0 : 1;\n  const seen = new Uint8Array(mask.length);\n  const stack = [];\n  for (let x = 0; x < width; x++) {\n    const top = 0 * width + x;\n    const bottom = (height - 1) * width + x;\n    if (inv[top] && !seen[top]) {\n      seen[top] = 1;\n      stack.push(top);\n    }\n    if (inv[bottom] && !seen[bottom]) {\n      seen[bottom] = 1;\n      stack.push(bottom);\n    }\n  }\n  for (let y = 0; y < height; y++) {\n    const left = y * width + 0;\n    const right = y * width + (width - 1);\n    if (inv[left] && !seen[left]) {\n      seen[left] = 1;\n      stack.push(left);\n    }\n    if (inv[right] && !seen[right]) {\n      seen[right] = 1;\n      stack.push(right);\n    }\n  }\n  while (stack.length) {\n    const cur = stack.pop();\n    const neighbors = [cur - 1, cur + 1, cur - width, cur + width];\n    for (const n of neighbors) {\n      if (n < 0 || n >= inv.length) continue;\n      if (!seen[n] && inv[n]) {\n        seen[n] = 1;\n        stack.push(n);\n      }\n    }\n  }\n  const out = new Uint8Array(mask.length);\n  for (let i = 0; i < mask.length; i++) {\n    if (mask[i]) out[i] = 1;else if (inv[i] && !seen[i]) out[i] = 1;else out[i] = 0;\n  }\n  return out;\n}\n\n// --- Merge close boxes ---\nfunction mergeCloseBoxes(boxes, gap = 8) {\n  if (!boxes || boxes.length <= 1) return boxes.slice();\n  const out = [];\n  const used = new Array(boxes.length).fill(false);\n  function overlapsOrClose(a, b) {\n    const ax1 = a.x,\n      ay1 = a.y,\n      ax2 = a.x + a.width,\n      ay2 = a.y + a.height;\n    const bx1 = b.x - gap,\n      by1 = b.y - gap,\n      bx2 = b.x + b.width + gap,\n      by2 = b.y + b.height + gap;\n    return !(ax2 < bx1 || ax1 > bx2 || ay2 < by1 || ay1 > by2);\n  }\n  for (let i = 0; i < boxes.length; i++) {\n    if (used[i]) continue;\n    let cur = Object.assign({}, boxes[i]);\n    used[i] = true;\n    for (let j = i + 1; j < boxes.length; j++) {\n      if (used[j]) continue;\n      if (overlapsOrClose(cur, boxes[j])) {\n        const nx = Math.min(cur.x, boxes[j].x);\n        const ny = Math.min(cur.y, boxes[j].y);\n        const nx2 = Math.max(cur.x + cur.width, boxes[j].x + boxes[j].width);\n        const ny2 = Math.max(cur.y + cur.height, boxes[j].y + boxes[j].height);\n        cur.x = nx;\n        cur.y = ny;\n        cur.width = nx2 - nx;\n        cur.height = ny2 - ny;\n        if (Array.isArray(cur.pixels) && Array.isArray(boxes[j].pixels)) {\n          cur.pixels = cur.pixels.concat(boxes[j].pixels);\n        }\n        if (Array.isArray(cur.contour) && Array.isArray(boxes[j].contour)) {\n          cur.contour = cur.contour.concat(boxes[j].contour);\n        }\n        cur.area = (cur.area || 0) + (boxes[j].area || 0);\n        used[j] = true;\n      }\n    }\n    out.push(cur);\n  }\n  return out;\n}\nexport default ShapeDetector;","map":{"version":3,"names":["ShapeDetector","constructor","threshold","minArea","detectShapes","imageData","t0","performance","now","width","height","data","mask","Uint8Array","i","p","length","r","g","b","l","morphologicalClose","fillHoles","seen","shapes","stack","y","x","idx","area","minX","minY","maxX","maxY","push","pixels","cur","pop","cx","cy","n1","n2","n3","n4","contour","_traceBoundary","boundingBox","mergeCloseBoxes","outShapes","s","Math","max","sqrt","perimeter","polygonPerimeter","eps","approx","douglasPeucker","approxClean","removeColinear","hull","convexHull","hullClean","circularity","PI","type","Infinity","forEach","w","h","ar","abs","center","centroidFromPixels","bbox","confidence","computeConfidence","vertices","rawVertices","t1","processingTime","boundary","left","right","up","down","orderBoundary","points","used","Array","fill","out","step","best","bestDist","dx","dy","d","a","hypot","sx","sy","round","vCount","base","circBoost","min","sizeBoost","log10","epsilon","slice","first","last","keep","perpendicularDistance","pt","t","projx","projy","j","maxDist","index","k","res","cross","o","pts","sort","lower","upper","concat","angleTolDeg","tol","prev","next","v1x","v1y","v2x","v2y","dot","ang","acos","pad","floor","any","ky","yy","kx","xx","out2","all","inv","top","bottom","neighbors","n","boxes","gap","overlapsOrClose","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","Object","assign","nx","ny","nx2","ny2","isArray"],"sources":["C:/Users/yadla/Downloads/shape-detection/frontend/src/utils/ShapeDetector.js"],"sourcesContent":["// frontend/src/utils/ShapeDetector.js\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n    this.minArea = 30;\n  }\n\n  async detectShapes(imageData) {\n    const t0 = performance.now();\n    const { width, height, data } = imageData;\n\n    // grayscale -> binary mask\n    let mask = new Uint8Array(width * height);\n    for (let i = 0, p = 0; i < data.length; i += 4, p++) {\n      const r = data[i], g = data[i + 1], b = data[i + 2];\n      const l = (0.299 * r + 0.587 * g + 0.114 * b) | 0;\n      mask[p] = l < this.threshold ? 1 : 0;\n    }\n\n    // morphology: close gaps and fill holes\n    mask = morphologicalClose(mask, width, height, 5);\n    mask = fillHoles(mask, width, height);\n\n    // connected components (4-neighbor)\n    const seen = new Uint8Array(width * height);\n    let shapes = [];\n    const stack = [];\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const idx = y * width + x;\n        if (mask[idx] === 1 && !seen[idx]) {\n          let area = 0;\n          let minX = x, minY = y, maxX = x, maxY = y;\n          stack.push(idx);\n          seen[idx] = 1;\n          const pixels = [];\n          while (stack.length) {\n            const cur = stack.pop();\n            const cx = cur % width;\n            const cy = (cur / width) | 0;\n            pixels.push({ x: cx, y: cy });\n            area++;\n            if (cx < minX) minX = cx;\n            if (cy < minY) minY = cy;\n            if (cx > maxX) maxX = cx;\n            if (cy > maxY) maxY = cy;\n\n            const n1 = cur - 1, n2 = cur + 1, n3 = cur - width, n4 = cur + width;\n            if (cx > 0) {\n              if (!seen[n1] && mask[n1] === 1) { seen[n1] = 1; stack.push(n1); }\n            }\n            if (cx < width - 1) {\n              if (!seen[n2] && mask[n2] === 1) { seen[n2] = 1; stack.push(n2); }\n            }\n            if (cy > 0) {\n              if (!seen[n3] && mask[n3] === 1) { seen[n3] = 1; stack.push(n3); }\n            }\n            if (cy < height - 1) {\n              if (!seen[n4] && mask[n4] === 1) { seen[n4] = 1; stack.push(n4); }\n            }\n          }\n\n          if (area >= this.minArea) {\n            const contour = this._traceBoundary(mask, width, height, minX, minY, maxX, maxY);\n            shapes.push({\n              pixels,\n              contour,\n              area,\n              boundingBox: { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 },\n            });\n          }\n        }\n      }\n    }\n\n    // merge nearby boxes\n    shapes = mergeCloseBoxes(shapes, 8);\n\n    const outShapes = [];\n    for (const s of shapes) {\n      if (!s.contour || s.contour.length < 6 || (s.area && s.contour.length < Math.max(6, Math.sqrt(s.area) * 0.15))) {\n        const b = s.boundingBox;\n        s.contour = [\n          { x: b.x, y: b.y },\n          { x: b.x + b.width, y: b.y },\n          { x: b.x + b.width, y: b.y + b.height },\n          { x: b.x, y: b.y + b.height }\n        ];\n      }\n\n      const perimeter = polygonPerimeter(s.contour);\n      const eps = Math.max(3, 0.03 * perimeter);\n\n      const approx = douglasPeucker(s.contour, eps);\n      const approxClean = removeColinear(approx, 8);\n      const hull = convexHull(approxClean);\n      const hullClean = removeColinear(hull, 8);\n\n      const area = s.area;\n      const circularity = perimeter > 0 ? (4 * Math.PI * area) / (perimeter * perimeter) : 0;\n\n      let type = 'polygon';\n      if (hullClean.length === 3) {\n        type = 'triangle';\n      } else if (hullClean.length === 4) {\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n        hullClean.forEach(p => {\n          if (p.x < minX) minX = p.x;\n          if (p.y < minY) minY = p.y;\n          if (p.x > maxX) maxX = p.x;\n          if (p.y > maxY) maxY = p.y;\n        });\n        const w = maxX - minX || 1;\n        const h = maxY - minY || 1;\n        const ar = w / h;\n        type = Math.abs(ar - 1) < 0.12 ? 'square' : 'rectangle';\n      } else if (circularity > 0.7) {\n        type = 'circle';\n      } else {\n        type = 'polygon';\n      }\n\n      const center = centroidFromPixels(s.pixels);\n      const bbox = s.boundingBox;\n      const confidence = computeConfidence(type, hullClean.length, circularity, area, perimeter);\n\n      outShapes.push({\n        type,\n        vertices: hullClean,\n        rawVertices: approx,\n        center,\n        area,\n        boundingBox: bbox,\n        confidence,\n      });\n    }\n\n    const t1 = performance.now();\n    return {\n      shapes: outShapes,\n      processingTime: t1 - t0,\n    };\n  }\n\n  _traceBoundary(mask, width, height, minX, minY, maxX, maxY) {\n    const boundary = [];\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        const idx = y * width + x;\n        if (mask[idx] !== 1) continue;\n        const left = x > 0 ? mask[idx - 1] : 0;\n        const right = x < width - 1 ? mask[idx + 1] : 0;\n        const up = y > 0 ? mask[idx - width] : 0;\n        const down = y < height - 1 ? mask[idx + width] : 0;\n        if (left === 0 || right === 0 || up === 0 || down === 0) {\n          boundary.push({ x, y });\n        }\n      }\n    }\n    return orderBoundary(boundary);\n  }\n}\n\n// utility helpers\n\nfunction orderBoundary(points) {\n  if (!points || points.length === 0) return [];\n  const used = new Array(points.length).fill(false);\n  const out = [];\n  let idx = 0;\n  out.push(points[idx]);\n  used[idx] = true;\n  for (let step = 1; step < points.length; step++) {\n    let best = -1;\n    let bestDist = Infinity;\n    const cur = out[out.length - 1];\n    for (let i = 0; i < points.length; i++) {\n      if (used[i]) continue;\n      const dx = points[i].x - cur.x;\n      const dy = points[i].y - cur.y;\n      const d = dx * dx + dy * dy;\n      if (d < bestDist) {\n        bestDist = d;\n        best = i;\n      }\n    }\n    if (best === -1) break;\n    used[best] = true;\n    out.push(points[best]);\n  }\n  return out;\n}\n\nfunction polygonPerimeter(points) {\n  let p = 0;\n  for (let i = 0; i < points.length; i++) {\n    const a = points[i];\n    const b = points[(i + 1) % points.length];\n    const dx = a.x - b.x, dy = a.y - b.y;\n    p += Math.hypot(dx, dy);\n  }\n  return p;\n}\n\nfunction centroidFromPixels(pixels) {\n  if (!pixels || pixels.length === 0) return { x: 0, y: 0 };\n  let sx = 0, sy = 0;\n  for (let i = 0; i < pixels.length; i++) {\n    sx += pixels[i].x;\n    sy += pixels[i].y;\n  }\n  return { x: Math.round(sx / pixels.length), y: Math.round(sy / pixels.length) };\n}\n\nfunction computeConfidence(type, vCount, circularity, area, perimeter) {\n  let base = 0.5;\n  if (type === 'triangle') base = 0.9;\n  if (type === 'square' || type === 'rectangle') base = 0.88;\n  if (type === 'circle') base = 0.93;\n  if (type === 'polygon') base = 0.65;\n  const circBoost = Math.min(0.15, Math.max(0, (circularity - 0.4) * 0.5));\n  const sizeBoost = Math.min(0.2, Math.log10(Math.max(10, area)) * 0.03);\n  return Math.max(0.12, Math.min(0.99, base + circBoost + sizeBoost));\n}\n\n// Douglas-Peucker\nfunction douglasPeucker(points, epsilon) {\n  if (!points || points.length < 3) return points.slice();\n  const first = 0, last = points.length - 1;\n  const stack = [[first, last]];\n  const keep = new Array(points.length).fill(false);\n  keep[first] = true;\n  keep[last] = true;\n\n  function perpendicularDistance(pt, a, b) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    if (dx === 0 && dy === 0) {\n      return Math.hypot(pt.x - a.x, pt.y - a.y);\n    }\n    const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);\n    const projx = a.x + t * dx;\n    const projy = a.y + t * dy;\n    return Math.hypot(pt.x - projx, pt.y - projy);\n  }\n\n  while (stack.length > 0) {\n    const [i, j] = stack.pop();\n    let maxDist = 0;\n    let index = -1;\n    for (let k = i + 1; k < j; k++) {\n      const d = perpendicularDistance(points[k], points[i], points[j]);\n      if (d > maxDist) { maxDist = d; index = k; }\n    }\n    if (maxDist > epsilon) {\n      keep[index] = true;\n      stack.push([i, index]);\n      stack.push([index, j]);\n    }\n  }\n\n  const res = [];\n  for (let i = 0; i < points.length; i++) if (keep[i]) res.push(points[i]);\n  return res;\n}\n\n// convex hull\nfunction cross(o, a, b) {\n  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\nfunction convexHull(points) {\n  if (!points || points.length <= 1) return points.slice();\n  const pts = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);\n  const lower = [];\n  for (const p of pts) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();\n    lower.push(p);\n  }\n  const upper = [];\n  for (let i = pts.length - 1; i >= 0; i--) {\n    const p = pts[i];\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();\n    upper.push(p);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\n// remove near-colinear consecutive points\nfunction removeColinear(points, angleTolDeg = 6) {\n  if (!points || points.length <= 3) return points.slice();\n  const res = [];\n  const tol = (angleTolDeg * Math.PI) / 180;\n  for (let i = 0; i < points.length; i++) {\n    const prev = points[(i - 1 + points.length) % points.length];\n    const cur = points[i];\n    const next = points[(i + 1) % points.length];\n\n    const v1x = prev.x - cur.x, v1y = prev.y - cur.y;\n    const v2x = next.x - cur.x, v2y = next.y - cur.y;\n    const n1 = Math.hypot(v1x, v1y) || 1;\n    const n2 = Math.hypot(v2x, v2y) || 1;\n    const dot = (v1x * v2x + v1y * v2y) / (n1 * n2);\n    const ang = Math.acos(Math.max(-1, Math.min(1, dot)));\n    if (Math.abs(Math.PI - ang) > tol) {\n      res.push(cur);\n    }\n  }\n  return res.length >= 3 ? res : points.slice();\n}\n\n// --- Morphology: closing ---\nfunction morphologicalClose(mask, width, height, k = 3) {\n  const out = new Uint8Array(mask.length);\n  const pad = Math.floor(k / 2);\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let any = 0;\n      for (let ky = -pad; ky <= pad; ky++) {\n        const yy = y + ky;\n        if (yy < 0 || yy >= height) continue;\n        for (let kx = -pad; kx <= pad; kx++) {\n          const xx = x + kx;\n          if (xx < 0 || xx >= width) continue;\n          if (mask[yy * width + xx]) { any = 1; break; }\n        }\n        if (any) break;\n      }\n      out[y * width + x] = any;\n    }\n  }\n\n  const out2 = new Uint8Array(mask.length);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let all = 1;\n      for (let ky = -pad; ky <= pad; ky++) {\n        const yy = y + ky;\n        if (yy < 0 || yy >= height) { all = 0; break; }\n        for (let kx = -pad; kx <= pad; kx++) {\n          const xx = x + kx;\n          if (xx < 0 || xx >= width) { all = 0; break; }\n          if (!out[yy * width + xx]) { all = 0; break; }\n        }\n        if (!all) break;\n      }\n      out2[y * width + x] = all ? 1 : 0;\n    }\n  }\n  return out2;\n}\n\n// --- Fill holes ---\nfunction fillHoles(mask, width, height) {\n  const inv = new Uint8Array(mask.length);\n  for (let i = 0; i < mask.length; i++) inv[i] = mask[i] ? 0 : 1;\n\n  const seen = new Uint8Array(mask.length);\n  const stack = [];\n  for (let x = 0; x < width; x++) {\n    const top = 0 * width + x; const bottom = (height - 1) * width + x;\n    if (inv[top] && !seen[top]) { seen[top]=1; stack.push(top); }\n    if (inv[bottom] && !seen[bottom]) { seen[bottom]=1; stack.push(bottom); }\n  }\n  for (let y = 0; y < height; y++) {\n    const left = y * width + 0; const right = y * width + (width - 1);\n    if (inv[left] && !seen[left]) { seen[left]=1; stack.push(left); }\n    if (inv[right] && !seen[right]) { seen[right]=1; stack.push(right); }\n  }\n\n  while (stack.length) {\n    const cur = stack.pop();\n    const neighbors = [cur-1, cur+1, cur-width, cur+width];\n    for (const n of neighbors) {\n      if (n < 0 || n >= inv.length) continue;\n      if (!seen[n] && inv[n]) { seen[n] = 1; stack.push(n); }\n    }\n  }\n\n  const out = new Uint8Array(mask.length);\n  for (let i = 0; i < mask.length; i++) {\n    if (mask[i]) out[i] = 1;\n    else if (inv[i] && !seen[i]) out[i] = 1;\n    else out[i] = 0;\n  }\n  return out;\n}\n\n// --- Merge close boxes ---\nfunction mergeCloseBoxes(boxes, gap = 8) {\n  if (!boxes || boxes.length <= 1) return boxes.slice();\n  const out = [];\n  const used = new Array(boxes.length).fill(false);\n\n  function overlapsOrClose(a, b) {\n    const ax1 = a.x, ay1 = a.y, ax2 = a.x + a.width, ay2 = a.y + a.height;\n    const bx1 = b.x - gap, by1 = b.y - gap, bx2 = b.x + b.width + gap, by2 = b.y + b.height + gap;\n    return !(ax2 < bx1 || ax1 > bx2 || ay2 < by1 || ay1 > by2);\n  }\n\n  for (let i = 0; i < boxes.length; i++) {\n    if (used[i]) continue;\n    let cur = Object.assign({}, boxes[i]);\n    used[i] = true;\n    for (let j = i + 1; j < boxes.length; j++) {\n      if (used[j]) continue;\n      if (overlapsOrClose(cur, boxes[j])) {\n        const nx = Math.min(cur.x, boxes[j].x);\n        const ny = Math.min(cur.y, boxes[j].y);\n        const nx2 = Math.max(cur.x + cur.width, boxes[j].x + boxes[j].width);\n        const ny2 = Math.max(cur.y + cur.height, boxes[j].y + boxes[j].height);\n        cur.x = nx; cur.y = ny; cur.width = nx2 - nx; cur.height = ny2 - ny;\n        if (Array.isArray(cur.pixels) && Array.isArray(boxes[j].pixels)) {\n          cur.pixels = cur.pixels.concat(boxes[j].pixels);\n        }\n        if (Array.isArray(cur.contour) && Array.isArray(boxes[j].contour)) {\n          cur.contour = cur.contour.concat(boxes[j].contour);\n        }\n        cur.area = (cur.area || 0) + (boxes[j].area || 0);\n        used[j] = true;\n      }\n    }\n    out.push(cur);\n  }\n  return out;\n}\n\nexport default ShapeDetector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}