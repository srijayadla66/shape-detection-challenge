{"ast":null,"code":"/**\n * ShapeDetector Class\n * Implements pure mathematical shape detection without ML/AI\n */\n\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n  }\n\n  /**\n   * Main detection method\n   * @param {ImageData} imageData - Canvas ImageData object\n   * @returns {Promise<Object>} Detection results\n   */\n  async detectShapes(imageData) {\n    const startTime = performance.now();\n\n    // Step 1: Convert to grayscale\n    const grayscale = this.toGrayscale(imageData);\n\n    // Step 2: Apply binary threshold\n    const binary = this.applyThreshold(grayscale, imageData.width, imageData.height);\n\n    // Step 3: Find contours\n    const contours = this.findContours(binary, imageData.width, imageData.height);\n\n    // Step 4: Analyze and classify each contour\n    const shapes = [];\n    for (const contour of contours) {\n      if (contour.length < 10) continue; // Skip noise\n\n      const shape = this.analyzeContour(contour);\n      if (shape && shape.area > 100) {\n        // Minimum area threshold\n        shapes.push(shape);\n      }\n    }\n    const processingTime = performance.now() - startTime;\n    return {\n      shapes,\n      processingTime,\n      imageWidth: imageData.width,\n      imageHeight: imageData.height\n    };\n  }\n\n  /**\n   * Convert image to grayscale\n   */\n  toGrayscale(imageData) {\n    const {\n      data,\n      width,\n      height\n    } = imageData;\n    const grayscale = new Uint8Array(width * height);\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      // Standard luminosity formula\n      grayscale[i / 4] = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);\n    }\n    return grayscale;\n  }\n\n  /**\n   * Apply binary threshold\n   */\n  applyThreshold(grayscale, width, height) {\n    const binary = new Uint8Array(width * height);\n    for (let i = 0; i < grayscale.length; i++) {\n      binary[i] = grayscale[i] < this.threshold ? 0 : 1;\n    }\n    return binary;\n  }\n\n  /**\n   * Find contours using connected component analysis\n   */\n  findContours(binary, width, height) {\n    const visited = new Uint8Array(width * height);\n    const contours = [];\n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const idx = y * width + x;\n        if (visited[idx] || binary[idx] === 0) continue;\n\n        // Found new contour, trace it\n        const contour = this.traceContour(binary, visited, x, y, width, height);\n        if (contour.length > 0) {\n          contours.push(contour);\n        }\n      }\n    }\n    return contours;\n  }\n\n  /**\n   * Trace a single contour using boundary following\n   */\n  traceContour(binary, visited, startX, startY, width, height) {\n    const contour = [];\n    const queue = [[startX, startY]];\n    const directions = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];\n    while (queue.length > 0) {\n      const [x, y] = queue.shift();\n      const idx = y * width + x;\n      if (visited[idx] || binary[idx] === 0) continue;\n      visited[idx] = 1;\n      contour.push({\n        x,\n        y\n      });\n\n      // Check if this is an edge point\n      let isEdge = false;\n      for (const [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          const nidx = ny * width + nx;\n          if (binary[nidx] === 0) {\n            isEdge = true;\n          } else if (!visited[nidx]) {\n            queue.push([nx, ny]);\n          }\n        }\n      }\n    }\n    return contour;\n  }\n\n  /**\n   * Analyze contour and classify shape\n   */\n  analyzeContour(contour) {\n    // Calculate bounding box\n    const boundingBox = this.calculateBoundingBox(contour);\n\n    // Calculate center\n    const center = {\n      x: Math.round(boundingBox.x + boundingBox.width / 2),\n      y: Math.round(boundingBox.y + boundingBox.height / 2)\n    };\n\n    // Calculate area\n    const area = boundingBox.width * boundingBox.height;\n\n    // Approximate polygon to get vertices\n    const polygon = this.approximatePolygon(contour);\n    const vertexCount = polygon.length;\n\n    // Calculate shape metrics\n    const aspectRatio = boundingBox.width / boundingBox.height;\n    const perimeter = this.calculatePerimeter(contour);\n    const circularity = 4 * Math.PI * area / (perimeter * perimeter);\n\n    // Classify shape\n    const {\n      type,\n      confidence\n    } = this.classifyShape(vertexCount, aspectRatio, circularity, boundingBox);\n    return {\n      type,\n      boundingBox,\n      center,\n      area: Math.round(area),\n      confidence: parseFloat(confidence.toFixed(2)),\n      vertices: polygon\n    };\n  }\n\n  /**\n   * Calculate bounding box for contour\n   */\n  calculateBoundingBox(contour) {\n    let minX = Infinity,\n      minY = Infinity;\n    let maxX = -Infinity,\n      maxY = -Infinity;\n    for (const point of contour) {\n      minX = Math.min(minX, point.x);\n      minY = Math.min(minY, point.y);\n      maxX = Math.max(maxX, point.x);\n      maxY = Math.max(maxY, point.y);\n    }\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  /**\n   * Approximate contour to polygon using Douglas-Peucker algorithm\n   */\n  approximatePolygon(contour, epsilon = 0.02) {\n    if (contour.length < 3) return contour;\n\n    // Sample contour points for approximation\n    const perimeter = this.calculatePerimeter(contour);\n    const eps = epsilon * perimeter;\n    return this.douglasPeucker(contour, eps);\n  }\n\n  /**\n   * Douglas-Peucker algorithm for polygon approximation\n   */\n  douglasPeucker(points, epsilon) {\n    if (points.length < 3) return points;\n\n    // Find point with maximum distance\n    let maxDist = 0;\n    let index = 0;\n    const end = points.length - 1;\n    for (let i = 1; i < end; i++) {\n      const dist = this.perpendicularDistance(points[i], points[0], points[end]);\n      if (dist > maxDist) {\n        maxDist = dist;\n        index = i;\n      }\n    }\n\n    // If max distance is greater than epsilon, recursively simplify\n    if (maxDist > epsilon) {\n      const left = this.douglasPeucker(points.slice(0, index + 1), epsilon);\n      const right = this.douglasPeucker(points.slice(index), epsilon);\n      return [...left.slice(0, -1), ...right];\n    } else {\n      return [points[0], points[end]];\n    }\n  }\n\n  /**\n   * Calculate perpendicular distance from point to line\n   */\n  perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    if (dx === 0 && dy === 0) {\n      return Math.sqrt(Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2));\n    }\n    const num = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\n    const den = Math.sqrt(dx * dx + dy * dy);\n    return num / den;\n  }\n\n  /**\n   * Calculate perimeter of contour\n   */\n  calculatePerimeter(contour) {\n    let perimeter = 0;\n    for (let i = 0; i < contour.length; i++) {\n      const current = contour[i];\n      const next = contour[(i + 1) % contour.length];\n      perimeter += Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n    }\n    return perimeter;\n  }\n\n  /**\n   * Classify shape based on geometric properties\n   */\n  classifyShape(vertices, aspectRatio, circularity, boundingBox) {\n    let type = 'polygon';\n    let confidence = 0.5;\n\n    // Circle detection\n    if (circularity > 0.75 && Math.abs(aspectRatio - 1) < 0.2) {\n      type = 'circle';\n      confidence = Math.min(0.95, circularity * 1.1);\n    }\n    // Triangle detection\n    else if (vertices >= 3 && vertices <= 4) {\n      type = 'triangle';\n      confidence = 0.85;\n    }\n    // Square detection\n    else if (vertices === 4 && Math.abs(aspectRatio - 1) < 0.15) {\n      type = 'square';\n      confidence = 0.90;\n    }\n    // Rectangle detection\n    else if (vertices === 4) {\n      type = 'rectangle';\n      confidence = 0.88;\n    }\n    // Polygon detection\n    else if (vertices >= 5) {\n      type = 'polygon';\n      confidence = 0.80;\n    }\n    return {\n      type,\n      confidence\n    };\n  }\n}\nexport default ShapeDetector;","map":{"version":3,"names":["ShapeDetector","constructor","threshold","detectShapes","imageData","startTime","performance","now","grayscale","toGrayscale","binary","applyThreshold","width","height","contours","findContours","shapes","contour","length","shape","analyzeContour","area","push","processingTime","imageWidth","imageHeight","data","Uint8Array","i","r","g","b","Math","floor","visited","y","x","idx","traceContour","startX","startY","queue","directions","shift","isEdge","dx","dy","nx","ny","nidx","boundingBox","calculateBoundingBox","center","round","polygon","approximatePolygon","vertexCount","aspectRatio","perimeter","calculatePerimeter","circularity","PI","type","confidence","classifyShape","parseFloat","toFixed","vertices","minX","Infinity","minY","maxX","maxY","point","min","max","epsilon","eps","douglasPeucker","points","maxDist","index","end","dist","perpendicularDistance","left","slice","right","lineStart","lineEnd","sqrt","pow","num","abs","den","current","next"],"sources":["C:/Users/yadla/Downloads/shape-detection/frontend/src/utils/ShapeDetector.js"],"sourcesContent":["/**\n * ShapeDetector Class\n * Implements pure mathematical shape detection without ML/AI\n */\n\nclass ShapeDetector {\n  constructor() {\n    this.threshold = 128;\n  }\n\n  /**\n   * Main detection method\n   * @param {ImageData} imageData - Canvas ImageData object\n   * @returns {Promise<Object>} Detection results\n   */\n  async detectShapes(imageData) {\n    const startTime = performance.now();\n    \n    // Step 1: Convert to grayscale\n    const grayscale = this.toGrayscale(imageData);\n    \n    // Step 2: Apply binary threshold\n    const binary = this.applyThreshold(grayscale, imageData.width, imageData.height);\n    \n    // Step 3: Find contours\n    const contours = this.findContours(binary, imageData.width, imageData.height);\n    \n    // Step 4: Analyze and classify each contour\n    const shapes = [];\n    \n    for (const contour of contours) {\n      if (contour.length < 10) continue; // Skip noise\n      \n      const shape = this.analyzeContour(contour);\n      if (shape && shape.area > 100) { // Minimum area threshold\n        shapes.push(shape);\n      }\n    }\n    \n    const processingTime = performance.now() - startTime;\n    \n    return {\n      shapes,\n      processingTime,\n      imageWidth: imageData.width,\n      imageHeight: imageData.height\n    };\n  }\n\n  /**\n   * Convert image to grayscale\n   */\n  toGrayscale(imageData) {\n    const { data, width, height } = imageData;\n    const grayscale = new Uint8Array(width * height);\n    \n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      // Standard luminosity formula\n      grayscale[i / 4] = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);\n    }\n    \n    return grayscale;\n  }\n\n  /**\n   * Apply binary threshold\n   */\n  applyThreshold(grayscale, width, height) {\n    const binary = new Uint8Array(width * height);\n    \n    for (let i = 0; i < grayscale.length; i++) {\n      binary[i] = grayscale[i] < this.threshold ? 0 : 1;\n    }\n    \n    return binary;\n  }\n\n  /**\n   * Find contours using connected component analysis\n   */\n  findContours(binary, width, height) {\n    const visited = new Uint8Array(width * height);\n    const contours = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const idx = y * width + x;\n        \n        if (visited[idx] || binary[idx] === 0) continue;\n        \n        // Found new contour, trace it\n        const contour = this.traceContour(binary, visited, x, y, width, height);\n        \n        if (contour.length > 0) {\n          contours.push(contour);\n        }\n      }\n    }\n    \n    return contours;\n  }\n\n  /**\n   * Trace a single contour using boundary following\n   */\n  traceContour(binary, visited, startX, startY, width, height) {\n    const contour = [];\n    const queue = [[startX, startY]];\n    const directions = [\n      [-1, -1], [0, -1], [1, -1],\n      [-1, 0],           [1, 0],\n      [-1, 1],  [0, 1],  [1, 1]\n    ];\n    \n    while (queue.length > 0) {\n      const [x, y] = queue.shift();\n      const idx = y * width + x;\n      \n      if (visited[idx] || binary[idx] === 0) continue;\n      \n      visited[idx] = 1;\n      contour.push({ x, y });\n      \n      // Check if this is an edge point\n      let isEdge = false;\n      for (const [dx, dy] of directions) {\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          const nidx = ny * width + nx;\n          if (binary[nidx] === 0) {\n            isEdge = true;\n          } else if (!visited[nidx]) {\n            queue.push([nx, ny]);\n          }\n        }\n      }\n    }\n    \n    return contour;\n  }\n\n  /**\n   * Analyze contour and classify shape\n   */\n  analyzeContour(contour) {\n    // Calculate bounding box\n    const boundingBox = this.calculateBoundingBox(contour);\n    \n    // Calculate center\n    const center = {\n      x: Math.round(boundingBox.x + boundingBox.width / 2),\n      y: Math.round(boundingBox.y + boundingBox.height / 2)\n    };\n    \n    // Calculate area\n    const area = boundingBox.width * boundingBox.height;\n    \n    // Approximate polygon to get vertices\n    const polygon = this.approximatePolygon(contour);\n    const vertexCount = polygon.length;\n    \n    // Calculate shape metrics\n    const aspectRatio = boundingBox.width / boundingBox.height;\n    const perimeter = this.calculatePerimeter(contour);\n    const circularity = (4 * Math.PI * area) / (perimeter * perimeter);\n    \n    // Classify shape\n    const { type, confidence } = this.classifyShape(\n      vertexCount,\n      aspectRatio,\n      circularity,\n      boundingBox\n    );\n    \n    return {\n      type,\n      boundingBox,\n      center,\n      area: Math.round(area),\n      confidence: parseFloat(confidence.toFixed(2)),\n      vertices: polygon\n    };\n  }\n\n  /**\n   * Calculate bounding box for contour\n   */\n  calculateBoundingBox(contour) {\n    let minX = Infinity, minY = Infinity;\n    let maxX = -Infinity, maxY = -Infinity;\n    \n    for (const point of contour) {\n      minX = Math.min(minX, point.x);\n      minY = Math.min(minY, point.y);\n      maxX = Math.max(maxX, point.x);\n      maxY = Math.max(maxY, point.y);\n    }\n    \n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  /**\n   * Approximate contour to polygon using Douglas-Peucker algorithm\n   */\n  approximatePolygon(contour, epsilon = 0.02) {\n    if (contour.length < 3) return contour;\n    \n    // Sample contour points for approximation\n    const perimeter = this.calculatePerimeter(contour);\n    const eps = epsilon * perimeter;\n    \n    return this.douglasPeucker(contour, eps);\n  }\n\n  /**\n   * Douglas-Peucker algorithm for polygon approximation\n   */\n  douglasPeucker(points, epsilon) {\n    if (points.length < 3) return points;\n    \n    // Find point with maximum distance\n    let maxDist = 0;\n    let index = 0;\n    const end = points.length - 1;\n    \n    for (let i = 1; i < end; i++) {\n      const dist = this.perpendicularDistance(\n        points[i],\n        points[0],\n        points[end]\n      );\n      \n      if (dist > maxDist) {\n        maxDist = dist;\n        index = i;\n      }\n    }\n    \n    // If max distance is greater than epsilon, recursively simplify\n    if (maxDist > epsilon) {\n      const left = this.douglasPeucker(points.slice(0, index + 1), epsilon);\n      const right = this.douglasPeucker(points.slice(index), epsilon);\n      \n      return [...left.slice(0, -1), ...right];\n    } else {\n      return [points[0], points[end]];\n    }\n  }\n\n  /**\n   * Calculate perpendicular distance from point to line\n   */\n  perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    \n    if (dx === 0 && dy === 0) {\n      return Math.sqrt(\n        Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2)\n      );\n    }\n    \n    const num = Math.abs(\n      dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x\n    );\n    const den = Math.sqrt(dx * dx + dy * dy);\n    \n    return num / den;\n  }\n\n  /**\n   * Calculate perimeter of contour\n   */\n  calculatePerimeter(contour) {\n    let perimeter = 0;\n    \n    for (let i = 0; i < contour.length; i++) {\n      const current = contour[i];\n      const next = contour[(i + 1) % contour.length];\n      \n      perimeter += Math.sqrt(\n        Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2)\n      );\n    }\n    \n    return perimeter;\n  }\n\n  /**\n   * Classify shape based on geometric properties\n   */\n  classifyShape(vertices, aspectRatio, circularity, boundingBox) {\n    let type = 'polygon';\n    let confidence = 0.5;\n    \n    // Circle detection\n    if (circularity > 0.75 && Math.abs(aspectRatio - 1) < 0.2) {\n      type = 'circle';\n      confidence = Math.min(0.95, circularity * 1.1);\n    }\n    // Triangle detection\n    else if (vertices >= 3 && vertices <= 4) {\n      type = 'triangle';\n      confidence = 0.85;\n    }\n    // Square detection\n    else if (vertices === 4 && Math.abs(aspectRatio - 1) < 0.15) {\n      type = 'square';\n      confidence = 0.90;\n    }\n    // Rectangle detection\n    else if (vertices === 4) {\n      type = 'rectangle';\n      confidence = 0.88;\n    }\n    // Polygon detection\n    else if (vertices >= 5) {\n      type = 'polygon';\n      confidence = 0.80;\n    }\n    \n    return { type, confidence };\n  }\n}\n\nexport default ShapeDetector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}